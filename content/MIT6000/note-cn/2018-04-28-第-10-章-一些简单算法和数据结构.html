---
title: 第 10 章　一些简单算法和数据结构
subtitle: 10 SOME SIMPLE ALGORITHMS AND DATA STRUCTURES
author: 曲政
date: 2018-04-28
slug: some-simple-algorithms-and-data-structures
tags:
- 
categories:
- mit60001
typora-root-url: ../../static
show_toc: yes
output: html_notebook
---



<div id="上一章的目的不是让你设计高效程序这一章的目的也不是设计厉害的算法现实一点的目的是什么" class="section level3">
<h3>上一章的目的不是让你设计高效程序，这一章的目的也不是设计厉害的算法，现实一点的目的是什么？</h3>
<p>上一章的目的：介绍分析复杂性需要用到的基本概念。</p>
<p>这一章的目的：to develop some general intuitions about how to approach questions of efficiency.</p>
</div>
<div id="傻傻的算法就不好吗" class="section level3">
<h3>傻傻的算法就不好吗？</h3>
<p>简单直白、肯定正确的算法，常常是较好的路。搞什么聪明算法，可能是浪费时间。</p>
<p>simple and obviously correct.</p>
</div>
<div id="为什么在第二章讲了穷举法二分法和-n-r-切线法" class="section level3">
<h3>为什么在第二章讲了穷举法、二分法和 N-R 切线法？</h3>
<p>重点是想传达这样的认识：程序效率的关键在于算法高下，而不在于编码技巧。</p>
<p>The major point was that the key to efficiency is a good algorithm, not clever coding tricks.</p>
</div>
<div id="科学工作者写程序的经验过程要走哪两步" class="section level3">
<h3>科学工作者写程序的经验过程要走哪两步？</h3>
<ul>
<li>先写个简单的算法，用小数据集运行，验证假设。</li>
<li>结果积极的话。</li>
<li>再写高效算法，在大数据集上反复运行。</li>
</ul>
</div>
<div id="学习算法的目标是有朝一日发明算法吗" class="section level3">
<h3>学习算法的目标是有朝一日发明算法吗？</h3>
<p>大科学家一辈子有一次机会就很幸运了。</p>
<p>波利亚的观点类似：理解问题，拆解问题，等价问题。</p>
<blockquote>
<p>to learn to reduce the most complex aspects of the problems we are faced with to previously solved problems.</p>
</blockquote>
<ul>
<li>理解问题内在的复杂性在哪里；</li>
<li>想办法把问题分解为子问题；</li>
<li>帮这些子问题，找到对应的伙伴，后者已经有高效的算法可以解决。</li>
</ul>
</div>
<div id="对于算法工程上实际的态度是怎样的" class="section level3">
<h3>对于算法，工程上实际的态度是怎样的？</h3>
<blockquote>
<p>Keep in mind that the most efficient algorithm is not always the algorithm of choice.</p>
</blockquote>
<p>并不总是在每处选择最高效的算法，因为那样的程序很难懂，没有必要搞得那么难懂 needlessly difficult to understand。</p>
<p>实际的好策略是：
- 先用最直截了当的方式解题，
- 然后调试 instrument 程序，
- 发现计算不顺的瓶颈，
- 找出改善该处复杂度的办法。
- 依此往复改良。</p>
</div>
<div id="search-algorithms" class="section level2">
<h2>10.1 Search Algorithms</h2>
<div id="什么是搜索算法" class="section level3">
<h3>什么是搜索算法？</h3>
<p>一种寻找的方法</p>
<ul>
<li>在哪里搜？搜索空间 search space，collection of items</li>
<li>搜什么？一个或一组元素，an item or group of items</li>
<li>依据什么？特征属性，with specific propertities</li>
</ul>
</div>
<div id="搜索空间一定是具体的吗" class="section level3">
<h3>搜索空间一定是具体的吗？</h3>
<p>具体：电子病例</p>
<p>抽象：整数集</p>
</div>
<div id="说-e-in-li-的算法复杂度-至好-是线性的逻辑是什么" class="section level3">
<h3>说 <code>e in li</code> 的算法复杂度 “至好” 是线性的逻辑是什么？</h3>
<pre class="python"><code>for i in range (len (L)):
    if L[i] == e:
        return True
return False</code></pre>
<ul>
<li>最坏输入数据情况下，<code>e</code> 不在 <code>L</code> 里，执行 <code>O(len(L))</code> 次测试。</li>
<li>各次测试都是常数时间吗？如果是，那么才可以说复杂度与 len (L) 是线性关系。</li>
<li>各次测试分为找到 <code>Li</code> 与比较。</li>
<li>元素比较是常数时间。</li>
<li>找到各个 <code>L[i]</code> 是常数时间吗？</li>
<li>我们默认系统找到对应地址的内容（从某个地址里提取元素）这个动作是常数时间。</li>
<li>那么问题简化为：Python 能否在常数时间内计算出下一个元素的地址。</li>
</ul>
</div>
<div id="python-怎样实现在常数时间里顺序索引元素" class="section level3">
<h3>Python 怎样实现在常数时间里顺序索引元素？</h3>
<p>先假想一个理想情况：
- 一个 list，每个元素都是 int。
- 在内存中顺序存储。
- 因为每个整数是 1 字长 byte 占 4 个或 8 个字节 bit（32 位处理器或 64 位，硬件决定）
- 计算索引地址：start+4*i</p>
<p>真实情况类似：列表的表现方式是 “长度 + 指针 1 + 指针 2+…”
- 指针就是固定长度的，有的 32 位，有的 64 位。
- 指针所指向的地址里，才是任意类型的元素。
- 计算索引地址：start+4+4*i。</p>
<p>!<span class="citation">[@列表的实现方式 | center | 600x0]</span>(<a href="http://www.ituring.com.cn/figures/2017/PythonIntroduction/13.d10z.001.png" class="uri">http://www.ituring.com.cn/figures/2017/PythonIntroduction/13.d10z.001.png</a>)</p>
</div>
<div id="python-对-list-的表示方式体现什么计算机技术" class="section level3">
<h3>Python 对 List 的表示方式体现什么计算机技术？</h3>
<p>间接引用，indirection 不直接：想要接触一个东西，先接触另一个东西，后者包含引用前者。</p>
<p>上面的写法有点生硬，我是不是可以翻译成下面这样。</p>
<p>托关系：不直接递红包，找认识人，建立信任保留回旋余地。</p>
<p>1950 年代开始，计算机科学家发现，这种方法可以解开很多问题。</p>
<p>用 variable 与 index 都是 indirection 的方式之一。</p>
</div>
<div id="在集合中查找元素至少是线性复杂度吗" class="section level3">
<h3>在集合中查找元素至少是线性复杂度吗？</h3>
<p>一般来说，O (len (L)) 是最好的程度，因为必须遍历每个元素。</p>
<p>但是如果有附加信息，可以做的更快。</p>
<p>比如：集合中的元素排列有序，比如说升序排列。</p>
<ul>
<li>从头开找，直到发现比 e 大的元素，就可以结束查找比较了，因为后面的元素也必定比 e 大，没有必要继续了。
<ul>
<li>它可以改善平均运行时间；</li>
<li>而不能改善最坏情况。</li>
</ul></li>
<li>用二分查找，每次缩小一半可能空间。
<ul>
<li>可以改善最坏情况。</li>
</ul></li>
</ul>
</div>
<div id="二分查找建立在什么假设的基础上" class="section level3">
<h3>二分查找建立在什么假设的基础上？</h3>
<p>可能空间有序。
- 实数空间天然全盘有序。比如求平方根的算法。
- 在 specification 里要求函数调用者承担保证 list 集合有序的责任。
- 可以在函数内校验实际参数给的集合是否有序；
- 但是校验有序性的动作，是 O (len (L)) 复杂度，失去用二分法降低复杂度的意义了。</p>
</div>
<div id="干嘛要在-search-函数内还写函数结果架空了-search-函数" class="section level3">
<h3>干嘛要在 search 函数内还写函数？结果架空了 search 函数。</h3>
<p>search 函数是 wrapper 包装 function，bSearch 是 helper 辅助 function。</p>
<p>因为 bSearch 的形式参数 low，high 只是实现方式，应该对使用者隐藏。</p>
</div>
<div id="在-bsearch-这个递归函数里递减函数有什么性质在哪里体现" class="section level3">
<h3>在 bSearch 这个递归函数里，递减函数有什么性质？在哪里体现？</h3>
<p>类似于 while 循环的递减函数，这里：</p>
<ol style="list-style-type: decimal">
<li>把行参对应的值映射为一个非负整数；</li>
<li>这个值为 0，递归结束；</li>
<li>递减函数的值随着每次递归都减小。</li>
</ol>
<pre class="python"><code>def search (L, e):
    &quot;&quot;&quot; 假设 L 是列表，其中元素按升序排列。
       如果 e 是 L 中的元素，则返回 True，否则返回 False&quot;&quot;&quot;

    def bSearch (L, e, low, high):
        #Decrements high - low
        if high == low: # 这里保证递减函数性质 2，到 0 停止递归。
            return L[low] == e
        mid = (low + high)//2
        if L[mid] == e:
            return True
        elif L[mid] &gt; e:
            if low == mid: #整数除法向下取整，m 可能等于 l，而不可能等于 h，所以最后 else：L[mid] &lt; e 的分支里，不用写 if 了。
                return False
            else:
                return bSearch (L, e, low, mid - 1) # 递减函数性质 3，递减。
        else:
            return bSearch (L, e, mid + 1, high) # 递减函数性质 3，递减。

    if len (L) == 0: # 这里保证递减函数的性质 1，非负。
        return False
    else:
        return bSearch (L, e, 0, len (L) - 1)</code></pre>
</div>
<div id="在-bsearch-的后半递归函数里为什么要写-mid1" class="section level3">
<h3>在 bSearch 的后半递归函数里，为什么要写 mid+1？</h3>
<p>保证能够踩到递减函数为 0 的点，结束递归。仅此而已？仅此而已就不简单。</p>
<p>如果不做 - 1 和 + 1，看个实例</p>
<pre class="python"><code>L =[0 1 2 3 4 5]
e = 2.5

1.
l = 0, h = 5
m = (0 + 5)//2 i.e 2
L [m=2] = 2 &lt; e=2.5

2.
l = 2, h = 5
m = 3
L[m=3] = 3 &gt; e=2.5

3.
l = 2, h = 3
m = 2
L[m=2] = 2 &lt; e=2.5

4.
l = 2, h = 3
与上步相同，死循环。。。</code></pre>
<p>可见，由于求 m 值的 // 向下取整，m 可能等于 l，如果在下一轮递归时 m 不加 1，就会陷入死循环。</p>
<p>以上，2018-04-24</p>
</div>
</div>
