---
title: 第 12 章　背包与图的最优化问题
subtitle: 12 KNAPSACK AND GRAPH OPTIMIZATION PROBLEMS
author: 曲政
date: 2018-04-30
slug: knapsack-and-graph-optimization-problems
tags:
- 
categories:
- mit60001
typora-root-url: ../../static
show_toc: yes
output: html_notebook
---



<div id="knapsack-and-graph-optimization-problems" class="section level1">
<h1>12 KNAPSACK AND GRAPH OPTIMIZATION PROBLEMS</h1>
<div id="学最优化问题的目的是什么" class="section level3">
<h3>学最优化问题的目的是什么？</h3>
<p>生活中有很多类似问题，比如 the biggest, the smallest, the most, the fewest, the fastest, the least expensive，可以映射为最优化问题，找到经典解法。</p>
</div>
<div id="最优化问题有哪两个部分" class="section level3">
<h3>最优化问题有哪两个部分？</h3>
<ul>
<li>An objective function. e.g. the airfare between Boston and Istanbul.</li>
<li>A set of constraints. e.g. an upper bound on the travel time.</li>
</ul>
</div>
<div id="本章的五个核心议题" class="section level3">
<h3>本章的五个核心议题？</h3>
<ul>
<li>很多具有重要现实意义的问题都可以表述为一种简单的形式，并顺理成章地使用计算方法来解决；</li>
<li>将一个貌似新鲜的问题归结为我们熟知问题的一个实例，就可以使用已有的方案解决这个问题；</li>
<li>很多其他问题都可以归结为背包问题和图的最优化问题；</li>
<li>穷举法提供了一种搜索最优解的简单方法，但在计算上经常是不可行的；</li>
<li>贪婪算法非常实用，经常可以为最优化问题找出相当好的解，但不一定是最优解。</li>
</ul>
</div>
<div id="knapsack-problems" class="section level2">
<h2>12.1 Knapsack Problems</h2>
<div id="入室盗贼遇到的财物以及他的三个心算结果" class="section level3">
<h3>入室盗贼遇到的财物，以及他的三个心算结果？</h3>
<table>
<thead>
<tr class="header">
<th align="center"></th>
<th align="center">价值</th>
<th align="center">重量</th>
<th align="center">价值 / 重量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">钟</td>
<td align="center">175</td>
<td align="center">10</td>
<td align="center">17.5</td>
</tr>
<tr class="even">
<td align="center">油画</td>
<td align="center">90</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
<tr class="odd">
<td align="center">收音机</td>
<td align="center">20</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr class="even">
<td align="center">花瓶</td>
<td align="center">50</td>
<td align="center">2</td>
<td align="center">25</td>
</tr>
<tr class="odd">
<td align="center">书</td>
<td align="center">10</td>
<td align="center">1</td>
<td align="center">10</td>
</tr>
<tr class="even">
<td align="center">电脑</td>
<td align="center">200</td>
<td align="center">20</td>
<td align="center">10</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于这个问题，找出近似解的最简单方法就是 ** 贪婪算法 **—— 窃贼会首先选择最好的物品，然后是次好的，这样继续下去，直到将背包装满。</p>
</blockquote>
<blockquote>
<p>当然，在此之前，窃贼必须确定什么是 “最好” 的。最好的物品是价值最高的，重量最轻的？还是具有最高价值 / 重量比值的呢？如果选择价值最高的物品，就应该只带电脑离开，这样可以得到 200 美元。如果选择重量最轻的，那么应该依次带走书、花瓶、收音机和油画，一共价值 170 美元。最后，如果确定 “最好” 的含义是价值 / 重量比值最高，那么应当首先拿走花瓶和钟。然后有三种物品的价值 / 重量比值都是 10，但背包里只能放下书了。拿走书之后，他还可以拿走收音机。这样，所有赃物的价值是 255 美元。</p>
</blockquote>
<p>不要误解贪婪算法，它确实是一种算法。
- 它表达了比较的依据：最好的。
- 它明确了顺序：依次选择。
- 它限制了边界：背包装满。</p>
</div>
<div id="表达贪婪算法的程序" class="section level3">
<h3>表达贪婪算法的程序？</h3>
<pre class="python"><code>class Item (object):
    &quot;&quot;&quot;将财物建立抽象概念，初始化它的三个属性，可以分别提取；同时定义打印输出的框架&quot;&quot;&quot;

    def __init__(self, n, v, w):
        self.name = n
        self.value = v
        self.weight = w

    def getName (self):
        return self.name

    def getValue (self):
        return self.value

    def getWeight (self):
        return self.weight

    def __str__(self):
        result = &#39;&lt;&#39; + self.name + &#39;, &#39; + str (self.value)\
                 + &#39;, &#39; + str (self.weight) + &#39;&gt;&#39;
        return result


def value (item):
    &quot;&quot;&quot;将 item tpye 的 object 映射为它的 value 值&quot;&quot;&quot;
    return item.getValue ()


def weightInverse (item):
    &quot;&quot;&quot;将 item tpye 的 object 映射为它的 weight 值的倒数&quot;&quot;&quot;
    return 1.0/item.getWeight ()


def density (item):
    &quot;&quot;&quot;将 item tpye 的 object 映射为它的 value/weight 值&quot;&quot;&quot;
    return item.getValue ()/item.getWeight ()


#greedy 函数是 greedy 算法的核心
def greedy (items, maxWeight, keyFunction):
    &quot;&quot;&quot; 假设 Items 是列表，maxWeight &gt;= 0
       keyFunctions 是上面定义的三个函数之一，将 item type 映射到它的某个可衡量的 data attribute&quot;&quot;&quot;itemsCopy = sorted (items, key=keyFunction, reverse = True) #这里用&quot; 什么是值得 &quot; 把财物做了排序，最坏情况 O (n*log (n))
    result = []
    totalValue, totalWeight = 0.0, 0.0
    for i in range (len (itemsCopy)):
        if (totalWeight + itemsCopy [i].getWeight ()) &lt;= maxWeight: #看看还能不能再拿一个？
            result.append (itemsCopy [i]) #再装一个
            totalWeight += itemsCopy [i].getWeight () #更新总重
            totalValue += itemsCopy [i].getValue () #更新总额
    return (result, totalValue)


def buildItems ():
    &quot;&quot;&quot;初始化类实例，批量初始化后没有分别绑定一个变量名，而是顺手加入了一个列表，给这个列表一个变量名。&quot;&quot;&quot;
    names = [&#39;clock&#39;,&#39;painting&#39;,&#39;radio&#39;,&#39;vase&#39;,&#39;book&#39;,&#39;computer&#39;]
    values = [175,90,20,50,10,200]
    weights = [10,9,4,2,1,20]
    Items = []
    for i in range (len (values)):
        Items.append (Item (names [i], values [i], weights [i]))
    return Items


def testGreedy (items, maxWeight, keyFunction):
    &quot;&quot;&quot;计算与打印一种结果&quot;&quot;&quot;
    taken, val = greedy (items, maxWeight, keyFunction)
    print (&#39;Total value of items taken is&#39;, val)
    for item in taken:
        print (&#39; &#39;, item)


def testGreedys (maxWeight = 20):
    &quot;&quot;&quot;在统一约束下，比较三种方式&quot;&quot;&quot;
    items = buildItems ()

    print (&#39;Use greedy by value to fill knapsack of size&#39;, maxWeight)
    testGreedy (items, maxWeight, value)

    print (&#39;\nUse greedy by weight to fill knapsack of size&#39;,
          maxWeight)
    testGreedy (items, maxWeight, weightInverse)
    
    print (&#39;\nUse greedy by density to fill knapsack of size&#39;,
          maxWeight)
    testGreedy (items, maxWeight, density)</code></pre>
<p>输出</p>
<pre class="commandline"><code>Use greedy by value to fill knapsack of size 20
Total value of items taken is 200.0
  &lt;computer, 200, 20&gt;

Use greedy by weight to fill knapsack of size 20
Total value of items taken is 170.0
  &lt;book, 10, 1&gt;
  &lt;vase, 50, 2&gt;
  &lt;radio, 20, 4&gt;
  &lt;painting, 90, 9&gt;

Use greedy by density to fill knapsack of size 20
Total value of items taken is 255.0
  &lt;vase, 50, 2&gt;
  &lt;clock, 175, 10&gt;
  &lt;book, 10, 1&gt;
  &lt;radio, 20, 4&gt;
</code></pre>
</div>
<div id="为什么说贪婪算法不是全局最优解" class="section level3">
<h3>为什么说贪婪算法不是全局最优解？</h3>
<p>三种定义 “最好” 的方式下，衡量单位重量价值（价值密度）的方式，得到的结论比另外两种好。</p>
<p>但是得到的取财物的组合就是最好的吗？如果换成其他组合，有没有可能价值更大？</p>
<p>有。</p>
<p>贪婪算法只是保证了在各自价值体系内，用这种排序后从大到小取财物的方式，能得到各自体系内的最优组合。</p>
<p>因为财物不能无限细分，如果可以的话，0/1 背包问题 就变成了 分数背包问题，或称 连续背包问题。对那样的问题，对于具有最高价值 / 重量比值的物品来说，肯定拿得越多越好。</p>
<blockquote>
<p>举例来说，假如我们的窃贼在一间屋子中只发现 3 种有价值的物品：一袋金粉、一袋银粉和一袋葡萄干。那么在这种情况下，密度贪婪算法肯定能找到最优解。</p>
</blockquote>
</div>
<div id="背包问题可以定义" class="section level3">
<h3>0/1 背包问题可以定义？</h3>
<ul>
<li>每个物品都可以用一个值对 &lt;价值，重量&gt; 表示；</li>
<li>背包能够容纳的物品总重量不能超过 w；</li>
<li>长度为 n 的向量 I 表示一个可用的物品集合，向量中的每个元素都代表一个物品；</li>
<li>长度为 n 的向量 V 表示物品是否被窃贼带走。如果 V [i] = 1，则物品 I [i] 被带走；如果 V [i] = 0，则物品 I [i] 没有被带走；</li>
<li>目标是找到一个 V，使得：</li>
</ul>
<p><span class="math display">\[ \sum^{n-1}_{i=0}{\rm V}[i]^*{\rm I}[i].{\rm value} \]</span></p>
<p>的值最大，并满足以下约束条件：</p>
<p><span class="math display">\[ \sum^{n-1}_{i=0}{\rm V}[i]*{\rm I}[i].{\rm weight}\leqslant w \]</span></p>
</div>
<div id="有没有办法求得-01-背包问题的全局最优解" class="section level3">
<h3>有没有办法求得 0/1 背包问题的全局最优解？</h3>
<p>穷举法。</p>
<ol style="list-style-type: decimal">
<li><p>枚举所有可能的物品组合。也就是说，生成物品集合的所有子集 (即物品集合的幂集)。</p></li>
<li><p>去掉所有超过背包允许重量的物品组合。</p></li>
<li><p>在余下的物品组合中，选出任意一个价值最大的组合。</p></li>
</ol>
<pre class="python"><code>from em_9_3_6_gempowerset import genPowerset, getBinaryRep

from em_12_1_greedy import *

def chooseBest (pset, maxWeight, getVal, getWeight):
    #计算复杂度是 n*2^n, n = len (items)
    bestVal = 0.0
    bestSet = None
    for items in pset: #pset 的长度是 2**len (items)
        itemsVal = 0.0
        itemsWeight = 0.0
        for item in items: #最长 len (items)
            itemsVal += getVal (item)
            itemsWeight += getWeight (item)
        if itemsWeight &lt;= maxWeight and itemsVal&gt; bestVal:
           bestVal = itemsVal
           bestSet = items
    return (bestSet, bestVal)

def testBest (maxWeight = 20):
    items = buildItems ()
    pset = genPowerset (items) #pset 的长度是 2**len (items), 计算复杂度是 O (2**len (items))
    taken, val = chooseBest (pset, maxWeight, Item.getValue,
                            Item.getWeight)# 计算复杂度是 n*2^n, n = len (items)
    print (&#39;Total value of items taken is&#39;, val)
    for item in taken:
        print (item)

testBest ()</code></pre>
<pre class="commandline"><code>Total value of items taken is 275.0
&lt;clock, 175, 10&gt;
&lt;painting, 90, 9&gt;
&lt;book, 10, 1&gt;</code></pre>
<p>暴力的穷举法确实最优，但是如果财物太多，那就太难算了。贪婪算法虽然不是全局最优，至少能及时给出我可以接受的&quot; 好 &quot; 结果。从这个角度看来，Ivan Boesky 说得有理：</p>
<blockquote>
<p>I think greed is healthy. You can be greedy and still feel good about yourself.</p>
</blockquote>
<p>他几个月后因内幕交易被判入狱 2 年，罚款 1 亿美金。</p>
<p>以上，2018-04-27 13:54:59</p>
</div>
</div>
</div>
